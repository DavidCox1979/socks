<html>
    <head>
        <title>PhpStats</title>
        <style type="text/css">
            body {
                margin-right:25px;
            }
            pre {
                border:1px #000 solid;
                padding:9px;
            }
            h1 {
                font-size:30px;
            }
            h2 {
                font-size:20px;
            }
            h1, h2, a {
                margin-left:10px;    
            }
            p, strong {
                margin-left:20px;
            }
            pre {
                margin-left:25px;
                width:800px;
            }
        </style>
    </head>
    <body>

    
    <a name="top"></a>
<ol>
    <li>
        <a href="#logging">Logging (PhpStats_Logger)</a>
        <ul>
            <li><a href="#logging_realtime">Real Time Logging</a></li>
            <li><a href="#logging_segmenting">Segment With Attributes</a></li>
            <li><a href="#logging_backdating">Back Dating</a></li>
        </ul>
    </li>
    <li>
        <a href="#reporting">Reporting (PhpStats_TimeInterval)</a>
        <ul>
            <li><a href="#reporting_hour">Hour</a></li>
            <li><a href="#reporting_day">Day</a></li>
            <li><a href="#reporting_month">Month</a></li>
            <li><a href="#reporting_segments">Segmented Report</a></li>
            <li><a href="#reporting_describesegment">Describe Segments (Attribute)</a></li>
            <li><a href="#reporting_describetypes">Describe Event Types</a></li>
        </ul>
    </li>
</ol>
    

<a name="logging"></a>
<h1>Logging (PhpStats_Logger)</h1>

<a name="logging_realtime"></a>
<h2>Real Time Logging</h2>
<p>PhpStats_Logger is used to record events. In it's simplest usage you simply instantiate the logger, and call the log method. It has one required paramater, an event type. You should use any string name you want (Example "click", "view").</p>

<pre class="code">
$logger = new PhpStats_Logger;
$logger->log('click');
</pre>

<a name="logging_segmenting"></a>
<h2>Segment With Attributes</h2>
<p>Attributes are key value pairs, represented by associative PHP arrays. Attributes are used to segment your data for reporting. When using the logger pass an optional associative array of attributes to the log method.</p>
<pre class="code">
$logger->log( 'click', array(
    'attribute' => 'value'
));
</pre>

<a name="logging_backdating"></a>
<h2>Back Dating</h2>
<p>So far we have covered real time events. The log method has a third optional paramater that can be used to record an event subsequent to it's happening. Pass a timestamp as the third paramater. If the post dated timestamp is omitted, the return value of time() is used to record a "real time" event.</p>

<pre class="code">
$timestamp = time() - 9000;
$logger->log( 'click', array(), $timestamp );
</pre>
<a href="#top">Back to Top</a>

<hr />

<a name="reporting"></a>
<h1>Reporting (PhpStats_TimeInterval)</h1>
<p>There are "TimeInterval" classes for each discrete chunk of time that can be analyzed. The PhpStats_TimeInterval interface defines a constructor that all time intervals use. We need an associative array describing the time interval we are asking about in order to insantiage an TimeInterval. Each Time Interval requires a time parts array that identifies the interval uniquely, as you can see in the following examples.</p>

<p>If you fail to provide all required time parts for a TimeInterval, a "Missing Time" Exception will be raised (PhpStats_TimeInterval_Exception_MissingTime).</p>

<a name="reporting_hour"></a>
<h2>Hour Report (PhpStats_TimeInterval_Hour)</h2>
<p>For an Hour Interval, we must pass a year, month, day &amp; hour in the form of the "time parts" array.</p>
<pre class="code">
$timeParts = array(
    'hour' => 4,
    'month' => 1,
    'day' => 23,
    'year' => 2010
);
$hour = new PhpStats_TimeInterval_Hour( $timeParts );
</pre>
<p>We can then "ask" the hour how many times it has "seen" an event type.</p>
<pre class="code">
echo $hour->getCount('click'); // "5"
</pre>

<a name="reporting_day"></a>
<h2>Day Report (PhpStats_TimeInterval_Day)</h2>
<pre class="code">
$timeParts = array(
    'month' => 1,
    'day' => 23,
    'year' => 2010
);
$day = new PhpStats_TimeInterval_Day( $timeParts );
echo $day->getCount('click'); // "50"
</pre>

<a name="reporting_month"></a>
<h2>Month Report (PhpStats_TimeInterval_Month)</h2>
<pre class="code">
$timeParts = array(
    'month' => 1,
    'year' => 2010
);
$month = new PhpStats_TimeInterval_Month( $timeParts );
echo $month->getCount('click'); // "500"
</pre>

<a name="reporting_segments"></a>
<h2>Segmenting Reports (Drill Down By Attribute)</h2>
<p>If you would like to segment a report you can pass optional attribute(s) array as the second argument of the constructor. Then when you count an event type for that interval, it will only count events that match all segment attributes supplied.</p>
<pre class="code">
// no segmenting
$hour = new PhpStats_TimeInterval_Hour( $timeParts );
echo $hour->getCount('click'); // "4"

// segmenting
$hour = new PhpStats_TimeInterval_Hour( $timeParts, array( 'a' => 1 ) );
echo $hour->getCount('click'); // "2"
</pre>
    
<a name="reporting_describesegment"></a>
<h2>Describe Segments (Attributes)</h2>

<p>An array of distinct attribute keys in use for an interval can be gotten with it's describeAttributeKeys() method.</p>
<pre class="code">
print_r( $hour->describeAttributeKeys() ); // array( 'attribute1', 'attribute2' );
</pre>

<p>An array of distinct attribute keys <b>AND their values</b> in use for an interval can be gotten with it's describeAttributesValues() method.</p>
<pre class="code">
print_r( $hour->describeAttributesValues() ); //  array('attribute1' => array( 'value1', 'value2' ) 
</pre>


<a name="reporting_describetypes"></a>
<h2>Describe Event Types</h2>

<p>An array of event types in use for an interval can be gotten with it's describeEventTypes() method</p>
<pre class="code">
print_r( $hour->describeEventTypes() ); // array( 'clicks', 'views' )
</pre>



    
    </body>
</html>
